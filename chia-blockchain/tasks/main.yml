---
- name: Load architecture specific vars
  ansible.builtin.include_vars: "{{ lookup('first_found', params) }}"
  vars:
    params:
      files:
        - '{{ansible_architecture}}.yml'
      paths:
        - 'vars'

- name: Load multi-user vars
  when: chia_multi_user_number is defined
  ansible.builtin.include_vars: "{{ lookup('first_found', params) }}"
  vars:
    params:
      files:
        - 'multi-user.yml'
      paths:
        - 'vars'

- name:
  when: chia_multi_user_number is defined
  ansible.builtin.debug:
    var: multi_user_vars
  vars:
    multi_user_vars:
      chia_multi_user_number: "{{ chia_multi_user_number }}"
      chia_daemon_port: "{{ chia_daemon_port }}"
      chia_timelord_launcher_port: "{{ chia_timelord_launcher_port }}"
      full_node_port: "{{ full_node_port }}"
      introducer_port: "{{ introducer_port }}"a
      chia_farmer_port: "{{ chia_farmer_port }}"
      chia_wallet_port: "{{ chia_wallet_port }}"
      chia_full_node_rpc_port: "{{ chia_full_node_rpc_port }}"
      chia_farmer_rpc_port: "{{ chia_farmer_rpc_port }}"
      chia_harvester_rpc_port: "{{ chia_harvester_rpc_port }}"
      chia_wallet_rpc_port: "{{ chia_wallet_rpc_port }}"
      chia_data_layer_port: "{{ chia_data_layer_port }}"
      chia_data_layer_rpc_port: "{{ chia_data_layer_rpc_port }}"
      chia_data_layer_host_port: "{{ chia_data_layer_host_port }}"

- name: Cleanup any old leftovers
  ansible.builtin.include_tasks: "cleanup.yml"

- name: Install Common Deps
  become: true
  ansible.builtin.apt:
    name:
      - netcat # Used by systemd "up" checks
    state: present
    update_cache: true
    cache_valid_time: 300
  register: apt_action
  retries: 100
  until: apt_action is success or ('Failed to lock apt for exclusive operation' not in apt_action.msg and '/var/lib/dpkg/lock' not in apt_action.msg)

- name: Stop Monit Service
  become: true
  ansible.builtin.service:
    name: monit
    state: stopped
  when: add_monit_config
  ignore_errors: true # This will still run if the error is not correct
  tags:
    - skip_ansible_lint

- name: Ensure chia directories exist
  # become, in case ownership is incorrect
  become: true
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    owner: "{{ user }}"
    group: "{{ group }}"
    recurse: true
  with_items:
    - "{{ chia_root }}/db"

- name: Ensure CHIA_ROOT is set in .bashrc
  become: true
  become_user: "{{ user }}"
  ansible.builtin.lineinfile:
    path: "/home/{{ user }}/.bashrc"
    regexp: '^export CHIA_ROOT='
    line: "export CHIA_ROOT={{ chia_root }}"
  when: chia_root_to_env

- name: Install HW VDF Client
  ansible.builtin.include_tasks: "hw-vdf.yml"
  when: chia_enable_hw_vdf

- name: Install from source
  ansible.builtin.include_tasks: "source.yml"
  when: chia_installation_method == "source"

- name: Install from apt
  ansible.builtin.include_tasks: "apt.yml"
  when: chia_installation_method == "apt"

- name: Init with custom CA
  ansible.builtin.include_tasks: "custom-ca.yml"

- name: Check if the stub DB was created, if we plan to overwrite it with the S3 DB
  become: true
  become_user: "{{ user }}"
  ansible.builtin.find:
    paths: "{{ chia_root }}/db/"
    # Files less than 10k, aka, the stub DB generated by chia init
    size: "-10k"
    patterns: "blockchain_{{ db_version }}_{{ network }}.sqlite"
  when: download_blockchain_db
  register: stub_db_output

- name: Delete the stub DB if it was present
  become: true
  become_user: "{{ user }}"
  ansible.builtin.file:
    path: "{{item.path}}"
    state: absent
  with_items: "{{ stub_db_output.files }}"
  when: download_blockchain_db

- name: Copy latest blockchain DB and cache files from S3
  become: true
  become_user: "{{ user }}"
  ansible.builtin.shell: |
    aws --no-progress s3 cp s3://{{ blockchain_backup_bucket }}/{{ network }}/blockchain_{{ db_version }}_{{ network }}.sqlite {{ chia_root }}/db/blockchain_{{ db_version }}_{{ network }}.sqlite
    aws --no-progress s3 cp s3://{{ blockchain_backup_bucket }}/{{ network }}/height-to-hash {{ chia_root }}/db/height-to-hash
    aws --no-progress s3 cp s3://{{ blockchain_backup_bucket }}/{{ network }}/sub-epoch-summaries {{ chia_root }}/db/sub-epoch-summaries
  args:
    creates: "{{ chia_root }}/db/blockchain_{{ db_version }}_{{ network }}.sqlite"
  when: download_blockchain_db
  tags:
    - skip_ansible_lint

- name: Copy latest crawler DB from S3
  become: true
  become_user: "{{ user }}"
  ansible.builtin.command: aws --no-progress s3 cp s3://{{ blockchain_backup_bucket }}/{{ network }}/{{ crawler_segment }}-crawler.db {{ chia_root }}/crawler.db
  args:
    creates: "{{ chia_root }}/crawler.db"
  when: download_crawler_db

- name: Chia Config
  become: true
  ansible.builtin.template:
    src: config.yaml.j2
    dest: "{{ chia_root }}/config/config.yaml"
    owner: "{{ user }}"
    group: "{{ group }}"
    mode: "0644"

# Since the actual chia config is reformatted when python edits it, save a hidden copy of the
# config as templated so we can tell if the config ACTUALLY changed, and only base restarts on
# this other config file
- name: Reference Config
  become: true
  ansible.builtin.template:
    src: config.yaml.j2
    dest: "{{ chia_root }}/config/.config.yaml"
    owner: "{{ user }}"
    group: "{{ group }}"
    mode: "0644"
  notify: restart-chia

- name: Add Keys
  become: true
  become_user: "{{ user }}"
  no_log: true # Don't expose secrets in logs
  ansible.builtin.shell: |
    echo "{{ item }}" | chia keys add -l ""
  environment:
    PATH: "/home/{{ user }}/chia-blockchain/venv/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
    CHIA_ROOT: "{{ chia_root }}"
  when:
    - keys | length
  with_items: "{{ keys }}"

# @TODO This is specific to source installs. Need to move to source tasks and add the equivalent for apt installs
- name: Allow python in venv to bind 53
  become: true
  ansible.builtin.shell: |
    setcap CAP_NET_BIND_SERVICE=+eip $(readlink -f /home/{{ user }}/chia-blockchain/venv/bin/python)
  when: '"crawler" in chia_enabled_services or "seeder" in chia_enabled_services'

- name: Chia Systemd Config Files
  become: true
  ansible.builtin.template:
    src: "systemd/chia-{{ item }}.service.j2"
    dest: "/etc/systemd/system/{{ chia_service_base }}-{{ item }}.service"
    owner: root
    group: root
    mode: "0644"
  notify:
    - systemd-daemon-reload
    - restart-chia
  with_items: "{{ chia_all_services }}"

- name: Ensure services that are not supposed to be enabled are stopped and disabled in systemd
  become: true
  ansible.builtin.systemd:
    name: "{{ chia_service_base }}-{{ item }}.service"
    daemon_reload: true
    enabled: "false"
    state: "stopped"
  # get the difference of 2 lists (items in chia_all_services that donâ€™t exist in chia_enabled_services)
  # also specifically excludes daemon, since that will never be listed in enabled_services, but is in all_services, but it shouldn't be touched by this step
  with_items: "{{ chia_all_services | difference(chia_enabled_services) | difference([\"daemon\"]) }}"
  register: systemd_action
  retries: 10
  until: systemd_action is success

- name: Chia Systemd Target
  become: true
  ansible.builtin.template:
    src: "systemd/chia.target.j2"
    dest: "/etc/systemd/system/{{ chia_service_base }}.target"
    owner: root
    group: root
    mode: "0644"
  notify: restart-chia

- name: Ensure the chia target is in desired boot and current state
  become: true
  ansible.builtin.systemd:
    name: "{{ chia_service_base }}.target"
    daemon_reload: true
    enabled: "{{ start_on_boot }}"
    state: "{{ start_now | ternary('started','stopped') }}"
  register: systemd_action
  retries: 10
  until: systemd_action is success

- name: Add vector config
  become: true
  ansible.builtin.template:
    src: chia-blockchain.vector.toml
    dest: /etc/vector/chia-blockchain.vector.toml
    mode: "0644"
  when: add_vector_config
  notify: restart-vector

- name: Add custom monit config to conf.d
  become: true
  ansible.builtin.template:
    src: monit_config.j2
    dest: /etc/monit/conf.d/chia_monit
    mode: "0644"
  when: add_monit_config
  notify: restart-monit

- name: Start Monit Service
  become: true
  ansible.builtin.service:
    name: monit
    state: started
  when: add_monit_config and monit_start_now
  register: systemd_action
  retries: 10
  until: systemd_action is success

- name: Setup periodic peer connect cron
  become: true
  become_user: "{{ user }}"
  ansible.builtin.cron:
    name: "Ensure connected to {{ item }}"
    user: "{{ user }}"
    minute: "{{ chia_periodic_connect_interval.minute }}"
    hour: "{{ chia_periodic_connect_interval.hour }}"
    job: "PATH=/home/{{ user }}/chia-blockchain/venv/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin CHIA_ROOT={{ chia_root }} chia peer full_node -a {{ item }}:{{ full_node_port }} >> /dev/null 2>&1"
  with_items: "{{ chia_periodic_connect_peers }}"
  when:
    - chia_periodic_connect_peers | length

- name: Set up script to generate new certs on first boot
  ansible.builtin.include_tasks: "cloudinit-certs.yml"
  when: chia_cloudinit_new_certs
